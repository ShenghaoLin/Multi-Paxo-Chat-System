#!/usr/bin/env python
# -*- coding: utf-8 -*-

""" This module defines the client class, and executing this module will
	automatically run a client in cmdl mode.

	To run this program, always including the first argument as the name of
	this client. If a message loss is needed, use the optional second argument.


	@author: Yangming Ke, Shenghao Lin
"""

import socket      
import select
from requests import get
from replica_utils import *
import threading
import sys
import time
from multiprocessing import Process


class Client():

	""" Client class used in this project. Sending and receive massages.
		Thre are 2 modes: cmdl line mode and batch mode.
		In cmdl line mode, messages are generated by command line inputs.
		In batch mode, messages are automatically generated from the given message file.

	Parameters:
		name: the name of this client, should be unique
		config: config file location
		message: message file location, used in batch mode
		mode: 0 for batch mode, 1 for cmdl mode
		p: message loss probability
	"""

	def __init__(self, name, config, message, mode, p = 0):
		self.p = p
		self.name = name
		self.config = config
		self.message = message
		self.view = 0
		self.mode = mode
		self.chat_hist_code = list()
		self.chat_history = ''
		self.lock = threading.Lock()
		self.sending = False
		self.server_config = get_config(config)
		self.console_input = list()
		self.msg_sent = 0


	def receive(self, s):
		""" Thread function in charge of receving incoming messages.

		Parameters:
			s: socket that is to receive messages
		"""

		while True:

			msg = complete_recv(s)

			# Empty message check
			if msg != '':

				# If the message is a reply from replica
				if msg[0] == REPLY:

					leader = msg[1:].split(' ')[0]
					m = msg[1:].split(' ')[1]

					# If this is a null execution message to fill the hole, ignore it
					if m == NULL_ACTION:
						continue

					hash_code = m.split('~`')[0] + '-' + m.split('~`')[1] 

					self.lock.acquire()
					
					# Check if this reply has been received before
					if hash_code not in self.chat_hist_code:

						# Update leader according to receivced message
						self.view = int(leader)
						real_msg = m.split('~`')[2].replace('-+-', ' ')

						# Record this message to the list of received messages
						self.chat_hist_code.append(hash_code)
						self.chat_history += (hash_code + ': ' + real_msg + '\n')
						
						# If the message is sent by this client, then the lock is released
						# A next message can be sent now
						if m.split('~`')[0] == self.name:
							self.sending = False
							if self.mode == 1:
								print('[Sent]')

						# Print the chat history on the screen in cmdl mode
						if self.mode == 1:
							if m.split('~`')[0] != self.name:
								print(m.split('~`')[0] + ': ' + real_msg)

						# Write to chat history log
						with open('../log/chat_history' + self.name + '.log', 'w') as f:
							f.write(self.chat_history)
						f.close()
					self.lock.release()


	def run(self):
		""" The main function run in the process of this client
		"""

		# Connect to all replicas
		sockets = list()
		for server in self.server_config:
			s = socket.socket()
			try:
				s.connect(server)
			except:
				print("Not connected")
			sockets.append((s, server))
			t = threading.Thread(target = self.receive, args = (s, ))
			t.daemon = True
			t.start()

		# Mode selector
		if self.mode == 0:
			self.run_batch_mode(sockets)
		else:
			self.run_cmdl_mode(sockets)


	def run_cmdl_mode(self, sockets):
		""" The function that runs the cmdl mode

		Arguments:
			sokets: list of all replica socekts
		"""

		# Start to read keyboard inputs
		reading_thread = threading.Thread(target = self.read_input)
		reading_thread.daemon = True
		reading_thread.start()

		# Send message
		while True:
			if len(self.console_input) > 0 and self.sending == False:
				self.send_msg(self.console_input.pop(0), sockets)


	def read_input(self):
		""" Thread function used to keep track of keyboard input in the cmdl mode
		"""

		while True:
			text = sys.stdin.readline()[:-1]
			self.console_input.append(text)


	def run_batch_mode(self, sockets):
		""" The function that runs the batch mode

		Arguments:
			sokets: list of all replica socekts
		"""

		# Read messages from file
		with open(self.message, 'r') as f:
			msgs = f.readlines()

		# Send out all messages
		for i in range(len(msgs)):
			self.send_msg(msgs[i], sockets)

		print(self.name + " done")

		# Wait for possible messages from other clients
		while True:
			continue


	def send_msg(self, m, sockets):
		""" Function that sends messages and wait for the reply

		Arguments:
			m: message to send
			sokets: list of all replica socekts
		"""

		self.sending = True

		# Keep sending out messages until a reply is received
		while self.sending:

			# Add prefixing (name + msg_NO) to the msg
			s = sockets[self.view]
			complete_send(s[0], s[1], MESSAGE + self.name + '~`' + str(self.msg_sent) + '~`' + m.replace(' ', '-+-'), p = self.p)
			
			# Try to send many messages to the view replica,
			# to avoid the effect of message loss
			for tt in range(10):

				if self.sending == False:
					break;
				complete_send(s[0], s[1], MESSAGE + self.name + '~`' + str(self.msg_sent) + '~`' + m.replace(' ', '-+-'), p = self.p)
				time.sleep(0.05)

			# No reply, then change view
			if self.sending:
				self.view = (self.view + 1) % len(self.server_config)
		self.msg_sent += 1

if __name__ == '__main__':
	config = '../data/servers.config'
	prob = 0
	if (len(sys.argv) > 2):
		prob = float(sys.argv[2])
	c = Client(sys.argv[1], config, '', 1, p = prob)
	c.run()
